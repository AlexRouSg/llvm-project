# Test MIR printer and parser to NOT have `typeId` field in callSites.
# `typeId` is used for propogating call site type identifiers for
# indirect targets only. This test does not contain any indirect targets.

# RUN: llc --call-graph-section %s -run-pass=none -o - | FileCheck %s
# CHECK-NOT: - { bb: {{.*}}, offset: {{.*}}, fwdArgRegs: [], typeId:
# CHECK: name: _Z3barii
# CHECK: callSites:
# CHECK-NEXT: - { bb: {{.*}}, offset: {{.*}}, fwdArgRegs: []
# CHECK-NEXT: - { bb: {{.*}}, offset: {{.*}}, fwdArgRegs: []
# CHECK: name: _Z3fooii
# CHECK: callSites:
# CHECK-NEXT: - { bb: {{.*}}, offset: {{.*}}, fwdArgRegs: []

--- |  
  ; Function Attrs: mustprogress noinline nounwind optnone uwtable
  define dso_local noundef i32 @_Z4fizzii(i32 noundef %x, i32 noundef %y) #0 !type !6 !type !6 {
  entry:
    %x.addr = alloca i32, align 4
    %y.addr = alloca i32, align 4
    store i32 %x, ptr %x.addr, align 4
    store i32 %y, ptr %y.addr, align 4
    %0 = load i32, ptr %x.addr, align 4
    %1 = load i32, ptr %y.addr, align 4
    %add = add nsw i32 %0, %1
    ret i32 %add
  }
  
  ; Function Attrs: mustprogress noinline nounwind optnone uwtable
  define dso_local noundef i32 @_Z4buzzii(i32 noundef %x, i32 noundef %y) #0 !type !6 !type !6 {
  entry:
    %x.addr = alloca i32, align 4
    %y.addr = alloca i32, align 4
    store i32 %x, ptr %x.addr, align 4
    store i32 %y, ptr %y.addr, align 4
    %0 = load i32, ptr %x.addr, align 4
    %1 = load i32, ptr %y.addr, align 4
    %mul = mul nsw i32 %0, %1
    ret i32 %mul
  }
  
  ; Function Attrs: mustprogress noinline nounwind optnone uwtable
  define dso_local noundef i32 @_Z3barii(i32 noundef %x, i32 noundef %y) #0 !type !6 !type !6 {
  entry:
    %x.addr = alloca i32, align 4
    %y.addr = alloca i32, align 4
    store i32 %x, ptr %x.addr, align 4
    store i32 %y, ptr %y.addr, align 4
    %0 = load i32, ptr %x.addr, align 4
    %1 = load i32, ptr %y.addr, align 4
    %call = call noundef i32 @_Z4buzzii(i32 noundef %0, i32 noundef %1) [ "callee_type"(metadata !"_ZTSFiiiE.generalized") ]
    %2 = load i32, ptr %x.addr, align 4
    %3 = load i32, ptr %y.addr, align 4
    %call1 = call noundef i32 @_Z4fizzii(i32 noundef %2, i32 noundef %3) [ "callee_type"(metadata !"_ZTSFiiiE.generalized") ]
    %sub = sub nsw i32 %call, %call1
    ret i32 %sub
  }
  
  ; Function Attrs: mustprogress noinline nounwind optnone uwtable
  define dso_local noundef i32 @_Z3fooii(i32 noundef %x, i32 noundef %y) #0 !type !6 !type !6 {
  entry:
    %x.addr = alloca i32, align 4
    %y.addr = alloca i32, align 4
    store i32 %x, ptr %x.addr, align 4
    store i32 %y, ptr %y.addr, align 4
    %0 = load i32, ptr %x.addr, align 4
    %1 = load i32, ptr %y.addr, align 4
    %call = call noundef i32 @_Z3barii(i32 noundef %0, i32 noundef %1) [ "callee_type"(metadata !"_ZTSFiiiE.generalized") ]
    ret i32 %call
  }  
  
  !6 = !{i64 0, !"_ZTSFiiiE.generalized"}

...
---
name:            _Z3barii
stack:
  - { id: 0, name: x.addr, size: 4 }
  - { id: 1, name: y.addr, size: 4 }
callSites:
  - { bb: 0, offset: 11, fwdArgRegs: [] }
  - { bb: 0, offset: 20, fwdArgRegs: [] }
body:             |
  bb.0.entry:
    liveins: $edi, $esi
  
    %2:gr32 = COPY $esi
    %0:gr32 = COPY $edi
    %1:gr32 = COPY killed %0
    %3:gr32 = COPY killed %2
    MOV32mr %stack.0.x.addr, 1, $noreg, 0, $noreg, %1 :: (store (s32) into %ir.x.addr)
    MOV32mr %stack.1.y.addr, 1, $noreg, 0, $noreg, %3 :: (store (s32) into %ir.y.addr)
    %17:gr32 = MOV32rm %stack.0.x.addr, 1, $noreg, 0, $noreg :: (load (s32) from %ir.x.addr)
    %16:gr32 = MOV32rm %stack.1.y.addr, 1, $noreg, 0, $noreg :: (load (s32) from %ir.y.addr)
    ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
    $edi = COPY %17
    $esi = COPY %16
    CALL64pcrel32 @_Z4buzzii, csr_64, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
    ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
    %15:gr32 = COPY $eax
    %5:gr32 = COPY %15
    %12:gr32 = MOV32rm %stack.0.x.addr, 1, $noreg, 0, $noreg :: (load (s32) from %ir.x.addr)
    %11:gr32 = MOV32rm %stack.1.y.addr, 1, $noreg, 0, $noreg :: (load (s32) from %ir.y.addr)
    ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
    $edi = COPY %12
    $esi = COPY %11
    CALL64pcrel32 @_Z4fizzii, csr_64, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
    ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
    %10:gr32 = COPY $eax
    %6:gr32 = COPY %10
    %7:gr32 = SUB32rr %5, %6, implicit-def $eflags
    $eax = COPY %7
    RET64 implicit $eax

...
---
name:            _Z3fooii
stack:
  - { id: 0, name: x.addr, size: 4 }
  - { id: 1, name: y.addr, size: 4 }
callSites:
  - { bb: 0, offset: 11, fwdArgRegs: [] }
body:             |
  bb.0.entry:
    liveins: $edi, $esi
  
    %2:gr32 = COPY $esi
    %0:gr32 = COPY $edi
    %1:gr32 = COPY killed %0
    %3:gr32 = COPY killed %2
    MOV32mr %stack.0.x.addr, 1, $noreg, 0, $noreg, %1 :: (store (s32) into %ir.x.addr)
    MOV32mr %stack.1.y.addr, 1, $noreg, 0, $noreg, %3 :: (store (s32) into %ir.y.addr)
    %9:gr32 = MOV32rm %stack.0.x.addr, 1, $noreg, 0, $noreg :: (load (s32) from %ir.x.addr)
    %8:gr32 = MOV32rm %stack.1.y.addr, 1, $noreg, 0, $noreg :: (load (s32) from %ir.y.addr)
    ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
    $edi = COPY %9
    $esi = COPY %8
    CALL64pcrel32 @_Z3barii, csr_64, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
    ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
    %7:gr32 = COPY $eax
    %4:gr32 = COPY %7
    $eax = COPY %4
    RET64 implicit $eax

...
